# 微信运动排行榜设计

微信运动排行榜是一个展示用户每日步数排名的功能，设计这样一个系统需要考虑多个方面。以下是设计方案的关键点：

## 核心功能需求

1. **步数数据采集**：从用户设备(手机/智能手环)收集每日步数
2. **数据存储**：高效存储大量用户的步数数据
3. **实时排名计算**：能够快速计算并展示用户间的排名
4. **社交互动**：支持好友间的点赞、评论等互动

## 系统架构设计

### 1. 数据采集层
- 客户端定时上报步数(如每30分钟或用户打开微信时)
- 使用压缩协议减少数据传输量
- 客户端本地缓存步数，网络恢复后补传

### 2. 数据处理层
- **消息队列**：接收高并发的步数上报请求(Kafka/RabbitMQ)
- **数据处理服务**：验证、清洗、聚合步数数据
- **实时计算**：使用流处理框架(Flink/Spark Streaming)计算实时排名

### 3. 数据存储
- **用户步数存储**：
    - Redis: 存储当天的实时步数(Sorted Set结构，方便排名)
    - MySQL: 持久化历史步数数据
- **排行榜缓存**：
    - Redis Sorted Set: 存储好友间的实时排名
    - 定时(如每小时)刷新全量排名

### 4. 服务层
- 排行榜服务：处理排名查询请求
- 社交互动服务：处理点赞、评论等操作
- 数据统计服务：生成用户步数趋势等分析数据

## 关键技术实现

### 排行榜实现方案
1. **Redis Sorted Set方案**：
    - 使用步数作为score，用户ID作为member
    - 天然支持排名查询(ZREVRANGE命令)
    - 示例代码：
      ```python
      # 更新用户步数
      redis.zadd("daily_steps:20230501", {"user1": 10000, "user2": 8000})
      
      # 获取前10名
      top10 = redis.zrevrange("daily_steps:20230501", 0, 9, withscores=True)
      
      # 获取用户排名
      user_rank = redis.zrevrank("daily_steps:20230501", "user1")
      ```

2. **分片排名方案**(应对海量用户)：
    - 按用户ID哈希分片
    - 定期合并各分片排名

### 性能优化
1. **多级缓存**：
    - 内存缓存热门好友圈的排名
    - Redis缓存全量排名
2. **异步计算**：
    - 非实时要求的计算(如历史排名)使用离线任务
3. **读写分离**：
    - 读操作走缓存和从库
    - 写操作走主库

## 数据库设计

### 用户步数表(steps_record)
```
id: bigint (PK)
user_id: bigint (索引)
date: date (索引, 格式YYYYMMDD)
steps: int (当日步数)
update_time: datetime
```

### 好友关系表(friend_relation)
```
id: bigint (PK)
user_id: bigint (索引)
friend_id: bigint (索引)
status: tinyint (关系状态)
create_time: datetime
```

## 挑战与解决方案

1. **高并发写入**：
    - 使用消息队列缓冲写入请求
    - 批量写入数据库

2. **实时排名计算**：
    - 使用Redis内存计算
    - 对非活跃用户延迟计算

3. **数据一致性**：
    - 最终一致性模型
    - 定期对账修复数据

4. **作弊防范**：
    - 设备指纹识别
    - 步数变化模式分析
    - 异常数据过滤

这个设计方案可以根据实际用户规模和性能要求进行调整，例如对于特别大的用户基数，可能需要考虑更复杂的分片和分布式计算策略。