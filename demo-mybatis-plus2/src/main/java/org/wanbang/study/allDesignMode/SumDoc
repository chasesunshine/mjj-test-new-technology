# 创建者模式(5节)
    # 第 1 节：⼯⼚⽅法模式
        适用场景：
            ⼯⼚模式⼜称⼯⼚⽅法模式，是⼀种创建型设计模式，其在⽗类中提供⼀个创建对象的⽅法， 允许⼦类
            决定实例化对象的类型。
            这种设计模式也是 Java 开发中最常⻅的⼀种模式，它的主要意图是定义⼀个创建对象的接⼝，让其⼦
            类⾃⼰决定实例化哪⼀个⼯⼚类，⼯⼚模式使其创建过程延迟到⼦类进⾏。
            简单说就是为了提供代码结构的扩展性，屏蔽每⼀个功能类中的具体实现逻辑。让外部可以更加简单的
            只是知道调⽤即可，同时，这也是去掉众多 ifelse 的⽅式。当然这可能也有⼀些缺点，⽐如需要实现
            的类⾮常多，如何去维护，怎样减低开发成本。但这些问题都可以在后续的设计模式结合使⽤中，逐步
            降低。
    # 第 2 节：抽象⼯⼚模式
        适用场景：
            抽象⼯⼚模式与⼯⼚⽅法模式虽然主要意图都是为了解决，接⼝选择问题。但在实现上，抽象⼯⼚是⼀
            个中⼼⼯⼚，创建其他⼯⼚的模式。
            可能在平常的业务开发中很少关注这样的设计模式或者类似的代码结构，但是这种场景确⼀直在我们身
            边，例如；
            1. 不同系统内的回⻋换⾏
            1. Unix系统⾥，每⾏结尾只有 <换⾏>，即 \n ；
            2. Windows系统⾥⾯，每⾏结尾是 <换⾏><回⻋>，即 \n\r ；
            3. Mac系统⾥，每⾏结尾是 <回⻋>
            2. IDEA 开发⼯具的差异展示(Win\Mac)
            除了这样显⽽易⻅的例⼦外，我们的业务开发中时常也会遇到类似的问题，需要兼容做处理。但⼤部分
            经验不⾜的开发⼈员，常常直接通过添加 ifelse ⽅式进⾏处理了。
    # 第 3 节：建造者模式
        适用场景：
            建造者模式所完成的内容就是通过将多个简单对象通过⼀步步的组装构建出⼀个复杂对象的过程。
            那么，哪⾥有这样的场景呢？
            例如你玩王者荣耀的时的初始化界⾯；有三条路、有树⽊、有ᰀ怪、有守卫塔等等，甚⾄依赖于你的⽹
            络情况会控制清晰度。⽽当你换⼀个场景进⾏其他不同模式的选择时，同样会建设道路、树⽊、ᰀ怪等
            等，但是他们的摆放和⼤⼩都有不同。这⾥就可以⽤到建造者模式来初始化游戏元素。
            ⽽这样的根据相同的 物料 ，不同的组装所产⽣出的具体的内容，就是建造者模式的最终意图，也就是；
            将⼀个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
    # 第 4 节：原型模式
        适用场景：
            原型模式主要解决的问题就是创建᯿复对象，⽽这部分 对象 内容本身⽐较复杂，⽣成过程可能从库或者
            RPC接⼝中获取数据的耗时较⻓，因此采⽤克隆的⽅式节省时间。
            其实这种场景经常出现在我们的身边，只不过很少⽤到⾃⼰的开发中，就像；
            1. 你经常 Ctrl+C 、 Ctrl+V ，复制粘贴代码。
            2. Java多数类中提供的API⽅法； Object clone() 。
            3. 细胞的有丝分裂。
            类似以上的场景并不少，但如果让你去思考平时的代码开发中，有⽤到这样的设计模式吗？确实不那么
            容易找到，甚⾄有时候是忽略了这个设计模式的⽅式。在没有阅读下⽂之前，也可以思考下哪些场景可
            以⽤到。
    # 第 5 节：单例模式
        适用场景：
            单例模式可以说是整个设计中最简单的模式之⼀，⽽且这种⽅式即使在没有看设计模式相关资料也会常
            ⽤在编码开发中。
            因为在编程开发中经常会遇到这样⼀种场景，那就是需要保证⼀个类只有⼀个实例哪怕多线程同时访
            问，并需要提供⼀个全局访问此实例的点。
            综上以及我们平常的开发中，可以总结⼀条经验，单例模式主要解决的是，⼀个全局使⽤的类频繁的创
            建和消费，从⽽提升提升整体的代码的性能。

# 结构型模式(7节)
    # 第 1 节：适配器模式
        适用场景：
            适配器模式的主要作⽤就是把原本不兼容的接⼝，通过适配修改做到统⼀。使得⽤户⽅便使⽤，就像我
            们提到的万能充、数据线、MAC笔记本的转换头、出国旅游买个插座等等，他们都是为了适配各种不同
            的 ⼝ ，做的兼容。
            除了我们⽣活中出现的各种适配的场景，那么在业务开发中呢？
            在业务开发中我们会经常的需要做不同接⼝的兼容，尤其是中台服务，中台需要把各个业务线的各种类
            型服务做统⼀包装，再对外提供接⼝进⾏使⽤。⽽这在我们平常的开发中也是⾮常常⻅的。
    # 第 2 节：桥接模式
        适用场景：
            桥接模式的主要作⽤就是通过将抽象部分与实现部分分离，把多种可匹配的使⽤进⾏组合。说⽩了核⼼
            实现也就是在A类中含有B类接⼝，通过构造函数传递B类的实现，这个B类就是设计的 桥 。
            那么这样的桥接模式，在我们平常的开发中有哪些场景
            JDBC多种驱动程序的实现、同品牌类型的台式机和笔记本平板、业务实现中的多类接⼝同组过滤服务
            等。这些场景都⽐较适合使⽤桥接模式进⾏实现，因为在⼀些组合中如果有如果每⼀个类都实现不同的
            服务可能会出现笛卡尔积，⽽使⽤桥接模式就可以⾮常简单。
    # 第 3 节：组合模式
        适用场景：
            从上图可以看到这有点像螺丝 和螺⺟，通过⼀堆的链接组织出⼀棵结构树。⽽这种通过把相似对象 (
            (也可以称作是⽅法)组合成⼀组可被调⽤的结构树对象的设计思路叫做组合模式。
            这种设计⽅式可以让你的服务组节点进⾏⾃由组合对外提供服务，例如你有三个原⼦校验功能( A：身份
            证 、 B：银⾏卡 、 C：⼿机号 )服务并对外提供调⽤使⽤。有些调⽤⽅需要使⽤AB组合，有些调⽤⽅需要
            使⽤到CBA组合，还有⼀些可能只使⽤三者中的⼀个。那么这个时候你就可以使⽤组合模式进⾏构建服
            务，对于不同类型的调⽤⽅配置不同的组织关系树，⽽这个树结构你可以配置到数据库中也可以不断的
            通过图形界⾯来控制树结构。
            所以不同的设计模式⽤在恰当好处的场景可以让代码逻辑⾮常清晰并易于扩展，同时也可以减少团队新
            增⼈员对项⽬的学习成本。
    # 第 4 节：装饰器模式
        适用场景：
            初看上图感觉装饰器模式有点像俄罗斯套娃、某众汽⻋ ，⽽装饰器的核⼼就是再不改原有类的基础上 )
            给类新增功能。不改变原有类，可能有的⼩伙伴会想到继承、AOP切⾯，当然这些⽅式都可以实现，但
            是使⽤装饰器模式会是另外⼀种思路更为灵活，可以避免继承导致的⼦类过多，也可以避免AOP带来的
            复杂性。
            你熟悉的场景很多⽤到装饰器模式
            new BufferedReader(new FileReader("")); ，这段代码你是否熟悉，相信学习java开发到字节
            流、字符流、⽂件流的内容时都⻅到了这样的代码，⼀层嵌套⼀层，⼀层嵌套⼀层，字节流转字符流等
            等，⽽这样⽅式的使⽤就是装饰器模式的⼀种体现。
    # 第 5 节：外观模式
        适用场景：
            外观模式也叫⻔⾯模式，主要解决的是降低调⽤⽅的使⽤接⼝的复杂逻辑组合。这样调⽤⽅与实际的接
            ⼝提供⽅提供⽅提供了⼀个中间层，⽤于包装逻辑提供API接⼝。有些时候外观模式也被⽤在中间件
            层，对服务中的通⽤性复杂逻辑进⾏中间件层包装，让使⽤⽅可以只关⼼业务开发。
            那么这样的模式在我们的所⻅产品功能中也经常遇到，就像⼏年前我们注册⼀个⽹站时候往往要添加很
            多信息，包括；姓名、昵称、⼿机号、QQ、邮箱、住址、单身等等，但现在注册成为⼀个⽹站的⽤户
            只需要⼀步即可，⽆论是⼿机号还是微信也都提供了这样的登录服务。⽽对于服务端应⽤开发来说以前
            是提供了⼀个整套的接⼝，现在注册的时候并没有这些信息，那么服务端就需要进⾏接⼝包装，在前端
            调⽤注册的时候服务端获取相应的⽤户信息(从各个渠道)，如果获取不到会让⽤户后续进⾏补全(营销补
            全信息给奖励)，以此来拉动⽤户的注册量和活跃度。
    # 第 6 节：享元模式
        适用场景：
            享元模式，主要在于共享通⽤对象，减少内存的使⽤，提升系统的访问效率。⽽这部分共享对象通常⽐
            较耗费内存或者需要查询⼤量接⼝或者使⽤数据库资源，因此统⼀抽离作为共享对象使⽤。
            另外享元模式可以分为在服务端和客户端，⼀般互联⽹H5和Web场景下⼤部分数据都需要服务端进⾏
            处理，⽐如数据库连接池的使⽤、多线程线程池的使⽤，除了这些功能外，还有些需要服务端进⾏包装
            后的处理下发给客户端，因为服务端需要做享元处理。但在⼀些游戏场景下，很多都是客户端需要进⾏
            渲染地图效果，⽐如；树⽊、花草、⻥⾍，通过设置不同元素描述使⽤享元公⽤对象，减少内存的占
            ⽤，让客户端的游戏更加流畅。
            在享元模型的实现中需要使⽤到享元⼯⼚来进⾏管理这部分独⽴的对象和共享的对象，避免出现线程安
            全的问题。
    # 第 7 节：代理模式
        适用场景：
            代理模式有点像⽼⼤和⼩弟，也有点像分销商。主要解决的是问题是为某些资源的访问、对象的类的易
            ⽤操作上提供⽅便使⽤的代理服务。⽽这种设计思想的模式经常会出现在我们的系统中，或者你⽤到过
            的组件中，它们都提供给你⼀种⾮常简单易⽤的⽅式控制原本你需要编写很多代码的进⾏使⽤的服务
            类。
            类似这样的场景可以想到；
            1. 你的数据库访问层⾯经常会提供⼀个较为基础的应⽤，以此来减少应⽤服务扩容时不⾄于数据库连
            接数暴增。
            2. 使⽤过的⼀些中间件例如；RPC框架，在拿到jar包对接⼝的描述后，中间件会在服务启动的时候⽣
            成对应的代理类，当调⽤接⼝的时候，实际是通过代理类发出的socket信息进⾏通过。
            3. 另外像我们常⽤的 MyBatis ，基本是定义接⼝但是不需要写实现类，就可以对 xml 或者⾃定义注
            解⾥的 sql 语句进⾏增删改查操作。

# ⾏为模式(10节)
    # 第 1 节：责任链模式
        适用场景：
            击⿎传雷，看上图你是否想起周星驰有⼀个电影，⼤家坐在海边围成⼀个圈，拿着⼀个点燃的炸弹，互
            相传递。
            责任链模式的核⼼是解决⼀组服务中的先后执⾏处理关系，就有点像你没钱花了，需要家庭财务⽀出审
            批，10块钱以下找闺⼥审批，100块钱先闺⼥审批在媳妇审批。你可以理解想象成当你要跳槽的时候被
            安排的明明⽩⽩的被各个领导签字放⾏。
    第 2 节：命令模式
        适用场景：
            命令模式在我们通常的互联⽹开发中相对来说⽤的⽐较少，但这样的模式在我们的⽇常中却经常使⽤
            到，那就是 Ctrl+C 、 Ctrl+V 。当然如果你开发过⼀些桌⾯应⽤，也会感受到这样设计模式的应⽤场
            景。从这样的模式感受上，可以想到这是把逻辑实现与操作请求进⾏分离，降低耦合⽅便扩展。
            命令模式是⾏为模式中的⼀种，以数据驱动的⽅式将 命令对象 ，可以使⽤构造函数的⽅式传递给调⽤
            者。调⽤者再提供相应的实现为命令执⾏提供操作⽅法。可能会感觉这部分有⼀些饶，可以通过对代码
            的实现进⾏理解，在通过实操来熟练。
            在这个设计模式的实现过程中有如下⼏个⽐较᯿要的点；
            1. 抽象命令类；声明执⾏命令的接⼝和⽅法
            2. 具体的命令实现类；接⼝类的具体实现，可以是⼀组相似的⾏为逻辑
            3. 实现者；也就是为命令做实现的具体实现类
            4. 调⽤者；处理命令、实现的具体操作者，负责对外提供命令服务
    第 3 节：迭代器模式
        适用场景：
            迭代器模式，常⻅的就是我们⽇常使⽤的 iterator 遍历。虽然这个设计模式在我们的实际业务开发中
            的场景并不多，但却⼏乎每天都要使⽤ jdk 为我们提供的 list 集合遍历。另外增强的for循环虽然是循
            环输出数据，但是他不是迭代器模式。迭代器模式的特点是实现 Iterable 接⼝，通过 next 的⽅式获
            取集合元素，同时具备对元素的删除等操作。⽽增强的for循环是不可以的。
            这种设计模式的优点是可以让我们以相同的⽅式，遍历不同的数据结构元素，这些数据结构包括； 数
            组 、 链表 、 树 等，⽽⽤户在使⽤遍历的时候并不需要去关⼼每⼀种数据结构的遍历处理逻辑，从让使
            ⽤变得统⼀易⽤。
    第 4 节：中介者模式
        适用场景：
            中介者模式要解决的就是复杂功能应⽤之间的᯿复调⽤，在这中间添加⼀层中介者包装服务，对外提供
            简单、通⽤、易扩展的服务能⼒。
            这样的设计模式⼏乎在我们⽇常⽣活和实际业务开发中都会⻅到，例如；⻜机

            降落有⼩姐姐在塔台喊
            话、⽆论哪个⽅向来的候⻋都从站台上下、公司的系统中有⼀个中台专⻔为你包装所有接⼝和提供统⼀
            的服务等等，这些都运⽤了中介者模式。除此之外，你⽤到的⼀些中间件，他们包装了底层多种数据库
            的差异化，提供⾮常简单的⽅式进⾏使⽤。
    第 5 节：备忘录模式
        适用场景：
            备忘录模式是以可以恢复或者说回滚，配置、版本、悔棋为核⼼功能的设计模式，⽽这种设计模式属于
            ⾏为模式。在功能实现上是以不破坏原对象为基础增加备忘录操作类，记录原对象的⾏为从⽽实现备忘
            录模式。
            这个设计在我们平常的⽣活或者开发中也是⽐较常⻅的，⽐如：后悔药、孟婆汤(⼀下回滚到0)，IDEA编
            辑和撤销、⼩霸王游戏机存档。当然还有我们⾮常常⻅的Photoshop，如下；
    第 6 节：观察者模式
        适用场景：
            简单来讲观察者模式，就是当⼀个⾏为发⽣时传递信息给另外⼀个⽤户接收做出相应的处理，两者之
            间没有直接的耦合关联。例如；狙击⼿、李云⻰。
            除了⽣活中的场景外，在我们编程开发中也会常⽤到⼀些观察者的模式或者组件，例如我们经常使⽤的
            MQ服务，虽然MQ服务是有⼀个通知中⼼并不是每⼀个类服务进⾏通知，但整体上也可以算作是观察者
            模式的思路设计。再⽐如可能有做过的⼀些类似事件监听总线，让主线服务与其他辅线业务服务分离，
            为了使系统降低耦合和增强扩展性，也会使⽤观察者模式进⾏处理。
    第 7 节：状态模式
        适用场景：
            状态模式描述的是⼀个⾏为下的多种状态变更，⽐如我们最常⻅的⼀个⽹站的⻚⾯，在你登录与不登录
            下展示的内容是略有差异的( 不登录不能展示个⼈信息 )，⽽这种 登录 与 不登录 就是我们通过改变状态，
            ⽽让整个⾏为发⽣了变化。
            ⾄少80后、90后的⼩伙伴基本都⽤过这种磁带放⾳机( 可能没有这个好看 )，它的上⾯是⼀排按钮，当放
            ⼊磁带后，通过上⾯的按钮就可以让放⾳机播放磁带上的内容( listen to 英语听⼒考试 )，⽽且有些按
            钮是互斥的，当在某个状态下才可以按另外的按钮( 这在设计模式⾥也是⼀个关键的点 )。
    第 8 节：策略模式
        适用场景：
            策略模式是⼀种⾏为模式，也是替代⼤量 ifelse 的利器。它所能帮你解决的是场景，⼀般是具有同类
            可替代的⾏为逻辑算法场景。⽐如；不同类型的交易⽅式(信⽤卡、⽀付宝、微信)、⽣成唯⼀ID策略
            (UUID、DB⾃增、DB+Redis、雪花算法、Leaf算法)等，都可以使⽤策略模式进⾏⾏为包装，供给外部
            使⽤。
            策略模式也有点像三国演义中诸葛亮给刘关张的锦囊；
                第⼀个锦囊：⻅乔国⽼，并把刘备娶亲的事情du搞得东吴⼈尽皆知。
                第⼆个锦囊：⽤谎⾔（曹操打荆州）骗泡在温柔乡⾥的刘备回去。
                第三个锦囊：让孙夫⼈摆平东吴的追兵，她是孙权妹妹，东吴将领惧她三分。
    第 9 节：模板模式
        适用场景：
            模板模式的核⼼设计思路是通过在，抽象类中定义抽象⽅法的执⾏顺序，并将抽象⽅法设定为只有⼦类
            实现，但不设计 独⽴访问 的⽅法。简单说也就是把你安排的明明⽩⽩的。
            就像⻄游记的99⼋⼗⼀难，基本每⼀关都是；师傅被掳⾛、打妖怪、妖怪被收⾛，具体什么妖怪你⾃⼰
            定义，怎么打你想办法，最后收⾛还是弄死看你本事，我只定义执⾏顺序和基本策略，具体的每⼀难由
            观⾳来安排。
    第 10 节：访问者模式
        适用场景：
            访问者要解决的核⼼事项是，在⼀个稳定的数据结构下，例如⽤户信息、雇员信息等，增加易变的业务
            访问逻辑。为了增强扩展性，将这两部分的业务解耦的⼀种设计模式。
            说⽩了访问者模式的核⼼在于同⼀个事物不同视⻆下的访问信息不同，⽐如⼀个 美⼥ ⼿⾥拿个 冰激
            凌 。⼩朋友会注意冰激凌，⼤朋友会找⾃⼰喜欢的地⽅观测敌情。
