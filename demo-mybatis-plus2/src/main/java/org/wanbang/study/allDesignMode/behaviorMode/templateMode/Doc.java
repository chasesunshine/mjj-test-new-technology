package org.wanbang.study.allDesignMode.behaviorMode.templateMode;
/**
* @description: TODO
* @author majiajian
* @date 2022/8/25 13:15
* @version 1.0
*/

/**
 *
 * 模板模式的核⼼设计思路是通过在，抽象类中定义抽象⽅法的执⾏顺序，并将抽象⽅法设定为只有⼦类
 * 实现，但不设计 独⽴访问 的⽅法。简单说也就是把你安排的明明⽩⽩的。
 * 就像⻄游记的99⼋⼗⼀难，基本每⼀关都是；师傅被掳⾛、打妖怪、妖怪被收⾛，具体什么妖怪你⾃⼰
 * 定义，怎么打你想办法，最后收⾛还是弄死看你本事，我只定义执⾏顺序和基本策略，具体的每⼀难由
 * 观⾳来安排。
 *
 */
public class Doc {

    /**
     *
     * 关于模版模式的核⼼点在于由抽象类定义抽象⽅法执⾏策略，也就是说⽗类规定了好⼀系列的执⾏标
     * 准，这些标准的串联成⼀整套业务流程。
     * 在这个场景中我们模拟爬⾍爬取各类商家的商品信息，⽣成推⼴海报( 海报中含带个⼈的邀请码 )赚取商品
     * 返利。声明，这⾥是模拟爬取，并没有真的爬取
     * ⽽整个的爬取过程分为；模拟登录、爬取信息、⽣成海报，这三个步骤，另外；
     * 1. 因为有些商品只有登录后才可以爬取，并且登录可以看到⼀些特定的价格这与未登录⽤户看到的价
     * 格不同。
     * 2. 不同的电商⽹站爬取⽅式不同，解析⽅式也不同，因此可以作为每⼀个实现类中的特定实现。
     * 3. ⽣成海报的步骤基本⼀样，但会有特定的商品来源标识。所以这样三个步骤可以使⽤模版模式来设
     * 定，并有具体的场景做⼦类实现。
     *
     */

    /**
     *
     * 通过上⾯的实现可以看到 模版模式 在定义统⼀结构也就是执⾏标准上⾮常⽅便，也就很好的控制
     * 了后续的实现者不⽤关⼼调⽤逻辑，按照统⼀⽅式执⾏。那么类的继承者只需要关⼼具体的业务逻
     * 辑实现即可。
     * 另外模版模式也是为了解决⼦类通⽤⽅法，放到⽗类中设计的优化。让每⼀个⼦类只做⼦类需要完
     * 成的内容，⽽不需要关⼼其他逻辑。这样提取公⽤代码，⾏为由⽗类管理，扩展可变部分，也就⾮
     * 常有利于开发拓展和迭代。
     * 但每⼀种设计模式都有⾃⼰的特定场景，如果超过场景外的建设就需要额外考虑
     * "
     * 其他模式的运
     * ⽤。⽽不是⾮要⽣搬硬套，否则⾃⼰不清楚为什么这么做，也很难让后续者继续维护代码。⽽想要
     * 活学活⽤就需要多加练习，有实践的经历
     *
     */

}
